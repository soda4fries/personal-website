---
import Heading from '@/components/Heading.astro';
import {
  FilteredPostsList,
  type PostDataForFilter,
} from '@/features/blog/components/FilteredPostsList';
import { BlogPostCard } from '@/features/blog';
import type { LanguageCode } from '@/i18n/ui';
import { useTranslations } from '@/i18n/ui';
import BaseLayout from '@/layouts/BaseLayout.astro';
import { type CollectionEntry as AstroCollectionEntry } from 'astro:content';
import { EmptyState } from '@/components/empty-state';

type Props = {
  posts: AstroCollectionEntry<'blog'>[];
  lang: LanguageCode;
};

const { posts, lang } = Astro.props;

const initialSearchQuery = Astro.url.searchParams.get('q') || '';
const initialTag = Astro.url.searchParams.get('tag') || '';

const texts = useTranslations(lang, 'blogPage');

import { getImage, type ImageMetadata } from 'astro:assets';

// Helper function to transform BlogEntry to PostDataForFilter
async function transformPostForClientFilter(
  post: AstroCollectionEntry<'blog'>
): Promise<PostDataForFilter> {
  let optimizedHeroImage = null;
  if (post.data.heroImage) {
    const image = await getImage({
      src: post.data.heroImage.url,
      widths: [400, 800],
      formats: ['webp', 'jpeg'],
    });
    optimizedHeroImage = {
      ...post.data.heroImage,
      url: {
        src: image.src,
        width: image.attributes.width,
        height: image.attributes.height,
        format: 'webp',
        srcset: image.srcset,
      },
    };
  }

  return {
    id: post.id,
    slug: post.id ?? '',
    title: post.data.title,
    description: post.data.description || '',
    tags: post.data.tags,
    body: post.body ?? '',
    pubDate: post.data.pubDate,
    heroImage: optimizedHeroImage,
    readingTimeMinutes: post.data.readingTimeMinutes,
  };
}

const allPostsForClient = await Promise.all(
  posts.map(transformPostForClientFilter)
);
const componentTexts = {
  searchPlaceholder: texts('searchPlaceholder'),
  filterByTagButtonLabel: texts('filterByTagButtonLabel'),
  noTagFound: texts('noTagFound'),
  selectTagCommandPlaceholder: texts('selectTagCommandPlaceholder'),
  allTagsLabel: texts('allTagsLabel'),
  noPostsFound: texts('noPostsFound'),
  showingAll: texts('showingAll') || 'Showing all',
  found: texts('found') || 'Found',
  of: texts('of') || 'of',
  posts: texts('posts') || 'posts',
  matching: texts('matching') || 'matching',
  publishedOn: texts('publishedOn') || 'Published on ',
  readingTimeSuffix: texts('readingTimeSuffix') || 'min read',
  readMore: texts('readMore') || 'Read more',
  matchesIn: texts('matchesIn') || 'Matches in',
};

const t = useTranslations(lang, 'blogPage');

const pageTitle = t('pageTitle');
const pageDescription = t('pageDescription');
---

<BaseLayout {pageTitle} {pageDescription}>
  <div class="container mx-auto px-4 py-8 md:py-12">
    <Heading title={t('title')} description={t('description')} />
    <FilteredPostsList
      client:load
      allPosts={allPostsForClient}
      texts={componentTexts}
      lang={lang}
      initialSearchQuery={initialSearchQuery}
      initialTag={initialTag}
    />

    {/* The enhanced FilteredPostsList now handles the posts display */}
    {/* Fallback for no JavaScript */}
    <noscript>
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-8">
        {
          posts.length > 0 ? (
            posts.map((postEntry) => (
              <BlogPostCard post={postEntry} lang={lang} />
            ))
          ) : (
            <EmptyState title={texts('noPostsFound')} />
          )
        }
      </div>
    </noscript>
  </div>
</BaseLayout>
